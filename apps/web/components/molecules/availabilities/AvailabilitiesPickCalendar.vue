<template>
  <OverCalendar
    :date="date"
    :weekdays="weekdayNumbers"
    :disable-previous="disablePrevious"
    :disable-next="disableNext"
    class="no-scroll elevation-2"
    @select:date="selectDay"
    @update:date="updateDate"
  >
    <template #day-label-header="{ date }">
      <div class="day-header">
        <p>{{ formatDateDay(date) }}</p>
        <p>{{ formatDateDayNumber(date) }}</p>
      </div>
    </template>
    <template #interval="{ date, hour }">
      <div
        v-if="isEndOfPeriod(hour)"
        class="event"
        :class="{
          'two-hours': !isPartyShift(hour),
          'one-hour': isPartyShift(hour),
          selected: isSelected(date, hour),
          saved: isSaved(date, hour),
          'is-error': hasError(date, hour),
        }"
        @click="selectHour(date, hour)"
      >
        {{ getAssociatedCharisma(date, hour) }}
      </div>
    </template>
  </OverCalendar>
</template>

<script lang="ts">
import { defineComponent } from "vue";
import { DateString, Hour, OverDate, Period } from "@overbookd/period";
import {
  AvailabilityDate,
  AvailabilityErrorMessage,
  InitOverDate,
} from "@overbookd/volunteer-availability";
import OverCalendar from "~/components/molecules/calendar/OverCalendar.vue";
import {
  ALL_HOURS,
  isAllDaySelected,
  isEndOfAvailabilityPeriod,
} from "~/utils/availabilities/availabilities";
import {
  SavedCharismaPeriod,
  getPeriodCharisma,
} from "~/utils/models/charisma-period.model";
import { isPartyShift } from "~/utils/shift/shift";
import {
  formatDateDayName,
  formatDateDayNumber,
  computeTomorrowDate,
} from "~/utils/date/date.utils";

export default defineComponent({
  name: "AvailabilitiesPickCalendar",
  components: { OverCalendar },
  props: {
    period: {
      type: Object as () => Period,
      required: true,
    },
    disablePreviousPeriod: {
      type: Boolean,
      required: true,
    },
    disableNextPeriod: {
      type: Boolean,
      required: true,
    },
  },
  emits: ["reach:period-end", "reach:period-start"],
  data: () => ({
    date: new Date(),
  }),
  computed: {
    disablePrevious(): boolean {
      const isStartOfPeriod =
        this.period.start.getTime() === this.date.getTime();
      return this.disablePreviousPeriod && isStartOfPeriod;
    },
    disableNext(): boolean {
      const isEndOfPeriod = this.period.end.getTime() === this.date.getTime();
      return this.disableNextPeriod && isEndOfPeriod;
    },
    charismaPeriods(): SavedCharismaPeriod[] {
      return this.$accessor.charismaPeriod.charismaPeriods ?? [];
    },
    selectedAvailabilities(): Period[] {
      return this.$accessor.volunteerAvailability.availabilities.selected;
    },
    savedAvailabilities(): Period[] {
      return this.$accessor.volunteerAvailability.availabilities.recorded;
    },
    availabilities(): Period[] {
      return this.$accessor.volunteerAvailability.availabilities.list;
    },
    errors(): AvailabilityErrorMessage[] {
      return this.$accessor.volunteerAvailability.availabilities.errors;
    },
    isSelected(): (date: DateString, hour: Hour) => boolean {
      return (date: DateString, hour: Hour) => {
        const { period } = OverDate.init({ date, hour });
        return this.selectedAvailabilities.some((availability) =>
          availability.includes(period),
        );
      };
    },
    isSaved(): (date: DateString, hour: Hour) => boolean {
      return (date: DateString, hour: Hour) => {
        const { period } = OverDate.init({ date, hour });
        return this.savedAvailabilities.some((availability) =>
          availability.includes(period),
        );
      };
    },
    isAvailableOn(): (date: DateString, hour: Hour) => boolean {
      return (date: DateString, hour: Hour) => {
        return this.isSaved(date, hour) || this.isSelected(date, hour);
      };
    },
    hasError(): (date: DateString, hour: Hour) => boolean {
      return (date: DateString, hour: Hour) => {
        const start = OverDate.init({ date, hour }).date;
        return this.errors.some(({ period }) => period.isIncluding(start));
      };
    },
    weekdayNumbers(): number[] {
      return this.generateWeekdayList([], new Date(this.period.start));
    },
  },
  watch: {
    period() {
      this.date = this.period.start;
    },
  },
  mounted() {
    this.date = this.period.start;
  },
  methods: {
    updateDate(date: string) {
      const nextDate = new Date(date);
      if (nextDate.getTime() > this.period.end.getTime()) {
        if (this.disableNextPeriod) return;
        return this.$emit("reach:period-end");
      }
      if (nextDate.getTime() < this.period.start.getTime()) {
        return this.$emit("reach:period-start");
      }
      this.date = nextDate;
    },
    isEndOfPeriod(hour: Hour): boolean {
      return isEndOfAvailabilityPeriod(hour);
    },
    isPartyShift(hour: Hour): boolean {
      return isPartyShift(hour);
    },
    formatDateDay(dateString: DateString): string {
      return formatDateDayName(dateString);
    },
    formatDateDayNumber(dateString: DateString): string {
      return formatDateDayNumber(dateString);
    },
    generateWeekdayList(weekdays: number[], date: Date): number[] {
      if (date > this.period.end) return weekdays;
      const weekday = date.getDay();
      const tomorrow = computeTomorrowDate(date);
      return this.generateWeekdayList([...weekdays, weekday], tomorrow);
    },
    selectHour(dateString: DateString, hour: Hour) {
      if (this.isSaved(dateString, hour)) return;

      const overDate = { date: dateString, hour };
      if (this.isSelected(dateString, hour))
        return this.unSelectAvailability(overDate);

      this.selectAvailability({ date: dateString, hour });
    },
    selectDay(dateString: DateString) {
      if (isAllDaySelected(this.availabilities)(dateString)) {
        return this.unSelectAvailabilities(dateString);
      }

      this.selectAvailabilities(dateString);
    },
    selectAvailability(date: InitOverDate) {
      const charisma = this.getAssociatedCharisma(date.date, date.hour);
      const selection = { date, charisma };

      this.$accessor.volunteerAvailability.selectAvailability(selection);
    },
    selectAvailabilities(date: DateString) {
      ALL_HOURS.filter((hour) => !this.isAvailableOn(date, hour)).map(
        (hour) => {
          const overDate = { date, hour };
          this.selectAvailability(overDate);
        },
      );
    },
    unSelectAvailability(date: InitOverDate) {
      const charisma = this.getAssociatedCharisma(date.date, date.hour);
      const selection = { date, charisma };

      this.$accessor.volunteerAvailability.unSelectAvailability(selection);
    },
    unSelectAvailabilities(date: DateString) {
      ALL_HOURS.filter((hour) => this.isSelected(date, hour)).map((hour) => {
        const overDate = { date, hour };
        this.unSelectAvailability(overDate);
      });
    },

    getAssociatedCharisma(date: DateString, hour: Hour): number {
      const { period } = AvailabilityDate.init({ date, hour });
      return getPeriodCharisma(this.charismaPeriods, period);
    },
  },
});
</script>

<style lang="scss" scoped>
.event {
  background-color: rgba(25, 118, 210, 0.2);
  width: 100%;
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.8);
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  user-select: none;
}

.selected {
  background-color: rgba(25, 118, 210, 1);
  color: white;
}

.saved {
  background-color: rgba(76, 175, 80, 1);
  color: white;
}

.is-error {
  background-color: red;
  color: white;
}

/* Hover only on computer but not with touchscreen */
@media (hover: hover) and (pointer: fine) {
  .event:hover:not(.saved) {
    background-color: rgba(25, 118, 210, 0.8);
  }
}

.one-hour {
  height: 100%;
}

.two-hours {
  height: 200%;
}

.day-header {
  min-height: 5rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;

  p {
    margin: 0;
  }
}

/* hide the scrollbar */
.no-scroll {
  .v-calendar-daily__head {
    margin-right: 0;
  }

  .v-calendar-daily__scroll-area {
    overflow: hidden;
  }
}
</style>
